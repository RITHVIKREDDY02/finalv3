for wingo game : 

https://tc9987.club/game/periods  period api : 

use payload - for 30sec game
: 
"vngo30s"

for 1min : game
: 
"vngo1"

for 3min : game
: 
"vngo3"
for 5 min : game
: 
"vngo5"

you have login code of tc so you dont need cookies i think so i will give you code as sample how to get predictions import asyncio
import time
import aiohttp
from telegram import Bot

# Telegram Bot Token & Channel ID
TELEGRAM_BOT_TOKEN = "8125239208:AAHnATtrT37_hqFSpXmpIaMq1fQwA5OKTNw"
TELEGRAM_CHANNEL_ID = "-1001837315678"

# API URLs
RESULT_API_URL = "https://tc9987.club/result/getResult"
PERIOD_API_URL = "https://tc9987.club/game/periods"

# Authentication Cookies
COOKIES = {
    "PHPSESSID": "7686ab0e0165639f79ff80ffa2915659",
    "bt_route": "d33b5c045d61da863bbd35549732365a",
    "sid": "u1829203_bf93c7988692e17c0ca80c9b3a6a"
}

# Headers
HEADERS = {
    "Accept": "application/json, text/javascript, */*; q=0.01",
    "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X)",
    "X-Requested-With": "XMLHttpRequest"
}

bot = Bot(token=TELEGRAM_BOT_TOKEN)
current_prediction = None
consecutive_losses = 0

def get_big_small(number):
    return "SMALL" if number in [0, 1, 2, 3, 4] else "BIG"

def get_red_green(number):
    return "RED" if number in [0, 2, 4, 6, 8] else "GREEN"

async def fetch_data(url, payload=None):
    async with aiohttp.ClientSession(cookies=COOKIES, headers=HEADERS) as session:
        async with session.post(url, json=payload) as response:
            return await response.json()

async def fetch_latest_results():
    payload = {"game": "vngo1", "category": "vngo", "page": 1, "limit": 10}
    data = await fetch_data(RESULT_API_URL, payload)
    return data["data"].get("list", []) if data and "data" in data else []

async def get_next_period():
    while True:
        data = await fetch_data(PERIOD_API_URL)
        if data and data.get("code") == 1 and "next" in data["data"]:
            return data["data"]["next"]
        await asyncio.sleep(1)

async def choose_best_prediction(results):
    bs_wins = sum(1 for r in results if get_big_small(r["open_num"][0]) == get_big_small(results[0]["open_num"][0]))
    color_wins = sum(1 for r in results if get_red_green(r["open_num"][0]) == get_red_green(results[0]["open_num"][0]))
    return "bs" if bs_wins >= color_wins else "color"

async def send_prediction():
    global current_prediction
    next_info = await get_next_period()
    next_period = next_info["period"]
    results = await fetch_latest_results()
    if not results:
        return

    prediction_mode = await choose_best_prediction(results)
    prediction = get_big_small(results[0]["open_num"][0]) if prediction_mode == "bs" else get_red_green(results[0]["open_num"][0])
    
    message = f"""
"""
    
    sent_message = await bot.send_message(TELEGRAM_CHANNEL_ID, message, parse_mode="HTML")
    current_prediction = {"period": next_period, "prediction": prediction, "mode": prediction_mode, "message_id": sent_message.message_id}

async def update_result():
    global current_prediction, consecutive_losses
    if not current_prediction:
        return

    results = await fetch_latest_results()
    latest = results[0] if results else None
    if latest and latest["period"] == current_prediction["period"]:
        actual = get_big_small(latest["open_num"][0]) if current_prediction["mode"] == "bs" else get_red_green(latest["open_num"][0])
        if actual == current_prediction["prediction"]:
            await bot.send_sticker(
                chat_id=TELEGRAM_CHANNEL_ID,
                sticker="CAACAgUAAxkBAAEyWQNnx1REzwS6iG841FtNqHkaTtkthQACWxUAAqoa4VZursiDNO2CLDYE",
                reply_to_message_id=current_prediction["message_id"]
            )
            consecutive_losses = 0
        else:
            consecutive_losses += 1
            if consecutive_losses >= 3:
                await bot.send_message(TELEGRAM_CHANNEL_ID, "‚ö†Ô∏è <b><u>Chart not stable</u> ü•π</b>\n\n <b>Wait for 2 minutes ü§©</b>", parse_mode="HTML")
                await asyncio.sleep(120)
                consecutive_losses = 0
        current_prediction = None

async def main():
    while True:
        start_time = time.time()
        elapsed = start_time % 60
        if elapsed > 0:
            await asyncio.sleep(60 - elapsed)

        await asyncio.sleep(2)
        print(f"[INFO] Updating result at {time.strftime('%H:%M:%S')}")
        await update_result()

        await asyncio.sleep(1)
        print(f"[INFO] Fetching current period & sending prediction at {time.strftime('%H:%M:%S')}")
        await send_prediction()

        elapsed = time.time() - start_time
        await asyncio.sleep(max(60 - elapsed, 0))

if __name__ == "__main__":
    asyncio.run(main())