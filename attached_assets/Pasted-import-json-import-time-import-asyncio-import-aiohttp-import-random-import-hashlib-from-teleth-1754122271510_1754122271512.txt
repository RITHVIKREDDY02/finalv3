import json
import time
import asyncio
import aiohttp
import random
import hashlib
from telethon import TelegramClient
from telethon.tl.functions.messages import SendStickerRequest
from telethon.tl.types import InputDocument, InputStickeredMediaDocument

# Telegram API credentials
api_id = 1234567  # Replace with your actual API ID
api_hash = 'your_api_hash_here'  # Replace with your actual API hash
TELEGRAM_CHANNEL_ID = -1002181975762  # Use int ID for channels

# Telethon client setup
client = TelegramClient('user_session', api_id, api_hash)

# API URLs and headers
PERIOD_API_URL = "https://imgametransit.com/api/webapi/GetGameIssue"
RESULT_API_URL = "https://imgametransit.com/api/webapi/GetNoaverageEmerdList"

HEADERS = {
    "accept": "application/json, text/plain, */*",
    "authorization": "Bearer ...",  # Your full token here
    "content-type": "application/json;charset=UTF-8",
    "origin": "https://okwinslots5.com",
    "referer": "https://okwinslots5.com/"
}

current_prediction = None
consecutive_losses = 0
loss_alert_sent = False
last_predictions = []


def get_big_small(number):
    return "SMALL" if number in [0, 1, 2, 3, 4] else "BIG"


def generate_signature_payload():
    random_str = hashlib.md5(str(random.random()).encode()).hexdigest()
    timestamp = int(time.time())
    return random_str, timestamp


def analyze_trend(results):
    if not isinstance(results, list) or len(results) < 10:
        return random.choice(["BIG", "SMALL"])

    try:
        last_numbers = [int(result["number"]) for result in results[:10]]
        weighted_score = 0
        for i, number in enumerate(last_numbers):
            weight = 3 if i == 0 else 2 if i == 1 else 1
            weighted_score += weight if get_big_small(number) == "BIG" else -weight

        streak = 1
        for i in range(1, len(last_numbers)):
            if get_big_small(last_numbers[i]) == get_big_small(last_numbers[i - 1]):
                streak += 1
            else:
                break

        prediction = (
            "SMALL" if get_big_small(last_numbers[0]) == "BIG" else "BIG"
        ) if streak >= 3 else (
            "BIG" if weighted_score > 0 else "SMALL"
        )

        if len(last_predictions) >= 3:
            last_3 = [p["result"] for p in last_predictions[-3:]]
            if all(r == "LOSS" and last_predictions[-1]["prediction"] == prediction for r in last_3):
                prediction = "SMALL" if prediction == "BIG" else "BIG"

        return prediction

    except Exception:
        return random.choice(["BIG", "SMALL"])


async def post_data(url, body):
    async with aiohttp.ClientSession() as session:
        async with session.post(url, headers=HEADERS, json=body) as response:
            text = await response.text()
            try:
                return json.loads(text)
            except:
                return None


async def fetch_latest_results():
    random_str, timestamp = generate_signature_payload()
    body = {
        "language": 0,
        "pageNo": 1,
        "pageSize": 10,
        "random": "2ebf765416c649e699c8cefbe76d811d",
        "signature": "E46ACB58F4289D251D7C7E1800B71DBB",
        "timestamp": 1744010120,
        "typeId": 1
    }
    data = await post_data(RESULT_API_URL, body)
    return data["data"].get("list", []) if data and "data" in data else []


async def get_current_period():
    random_str, timestamp = generate_signature_payload()
    body = {
        "language": 0,
        "random": "ea8e64299cf844369e59ce6c6a95096b",
        "signature": "A95282C91E942DDA8DAE51C81F20DADB",
        "timestamp": 1744010099,
        "typeId": 1
    }
    data = await post_data(PERIOD_API_URL, body)
    return data.get("data", {}) if data else None


async def send_prediction():
    global current_prediction
    current_info = await get_current_period()
    if not current_info:
        return

    current_period = current_info.get("issueNumber")
    results = await fetch_latest_results()
    if not results:
        return

    prediction = analyze_trend(results)

    message = f"""
üèÜ <b>TASHAN-WIN WINGO 1MIN</b> üèÜ

üîì <b>PERIOD ID</b> - {current_period} - <b>{prediction}</b>

<i><b>Game Link:</b></i> <a href="https://www.tashanwin.in/#/">https://www.tashanwin.in/#/</a>
"""

    try:
        msg = await client.send_message(
            entity=TELEGRAM_CHANNEL_ID,
            message=message,
            parse_mode='html',
            link_preview=False
        )
        print(f"[SUCCESS] Sent prediction for period {current_period}")
        current_prediction = {
            "period": current_period,
            "prediction": prediction,
            "message_id": msg.id
        }
    except Exception as e:
        print(f"[ERROR] Failed to send prediction: {e}")


async def update_result():
    global current_prediction, consecutive_losses, loss_alert_sent, last_predictions
    if not current_prediction:
        return

    results = await fetch_latest_results()
    latest = results[0] if results else None

    if latest and latest.get("issueNumber") == current_prediction["period"]:
        actual = get_big_small(int(latest["number"]))
        predicted = current_prediction["prediction"]

        if actual == predicted:
            await client.send_file(
                TELEGRAM_CHANNEL_ID,
                file="https://stickers.telegram.org/static/sticker.webp",  # Replace with a valid local file if needed
                reply_to=current_prediction["message_id"]
            )
            consecutive_losses = 0
            loss_alert_sent = False
            last_predictions.append({"prediction": predicted, "result": "WIN"})
        else:
            consecutive_losses += 1
            last_predictions.append({"prediction": predicted, "result": "LOSS"})
            if consecutive_losses >= 3 and not loss_alert_sent:
                await client.send_message(
                    TELEGRAM_CHANNEL_ID,
                    "<b>üëÄ Manage Level 8 Level Funds For SureShots</b>",
                    parse_mode='html'
                )
                loss_alert_sent = True

        if len(last_predictions) > 10:
            last_predictions = last_predictions[-10:]

        current_prediction = None


async def main():
    await client.start()
    while True:
        start_time = time.time()
        elapsed = start_time % 60
        if elapsed > 0:
            await asyncio.sleep(60 - elapsed)

        await asyncio.sleep(2)
        await update_result()

        await asyncio.sleep(1)
        await send_prediction()

        elapsed = time.time() - start_time
        await asyncio.sleep(max(60 - elapsed, 0))


if __name__ == "__main__":
    asyncio.run(main())